module 'Line Follower' Input
author Ste7an
version 1 3 
choices set_calibration minimum maximum 
choices get_calibration minimum maximum average 
choices led_modes off on inverted position 
choices commands 'mode raw' 'mode calibrated' 'get version' debug calibrate 'is calibrated' 'load calibration' 'save calibration' 'get minimum' 'get maximum' 'set minimum' 'set maximum' neopixel 'set leds' 
description 'I2C Line follower on ch32v203'
variables _buf _line_plot _line_buf a _inverted _nr_sensors tmp buf _can_measure 

  spec ' ' 'init_line' 'init line _ plot _' 'num bool' 8 true
  spec 'r' 'read line' 'read line'
  spec 'r' '_bar_nr' '_bar_nr _' 'auto' '10'
  spec ' ' 'invert' 'invert _' 'bool' true
  spec 'r' 'get position' 'get position'
  spec ' ' 'set emitter level' 'set emitter level _' 'auto' '10'
  spec ' ' 'set calibration' 'set calibration _ values _' 'str.set_calibration auto' 'minimum' '10'
  spec ' ' 'command' 'command _ : value _' 'str.commands num' 'mode raw' 0
  spec 'r' 'get calibration' 'get calibration _' 'str.get_calibration' 'minimum'
  spec 'r' 'is calibrated' 'is calibrated'
  spec ' ' 'save calibration' 'calibration to file'
  spec ' ' 'load calibration' 'calibration from file'
  spec 'r' 'position_i2c' 'position_i2c'
  spec ' ' 'store calibration' 'store calibration'
  spec ' ' 'restore calibration' 'restore calibration'
  spec ' ' 'neopixel' 'neopixel _ color _' 'auto color' '10'
  spec ' ' 'led mode' 'led mode _' 'str.led_modes' 'on'
  spec 'r' 'get version' 'get version'

to '_bar_nr' nr {
  return ('[data:join]' 'bar' nr)
}

to command cmd args {
  local 'cmd_id' 0
  if (cmd == 'mode raw') {
    cmd_id = 0
  } (cmd == 'mode calibrated') {
    cmd_id = 1
  } (cmd == 'get version') {
    cmd_id = 2
  } (cmd == 'debug') {
    cmd_id = 3
  } (cmd == 'calibrate') {
    cmd_id = 4
  } (cmd == 'is calibrated') {
    cmd_id = 5
  } (cmd == 'load calibration') {
    cmd_id = 6
  } (cmd == 'save calibration') {
    cmd_id = 7
  } (cmd == 'get minimum') {
    cmd_id = 8
  } (cmd == 'get maximum') {
    cmd_id = 9
  } (cmd == 'set minimum') {
    cmd_id = 10
  } (cmd == 'set maximum') {
    cmd_id = 11
  } (cmd == 'neopixel') {
    cmd_id = 12
  } (cmd == 'set leds') {
    cmd_id = 13
  } (cmd == 'set emitter') {
    cmd_id = 14
  }
  if ((argOrDefault 2 'None') == 'None') {
    local 'buf' ('[data:makeList]' cmd_id)
  } else {
    local 'buf' ('[data:makeList]' cmd_id args)
  }
  '[sensors:i2cWrite]' 51 buf
}

to 'get calibration' minmax {
  _can_measure = (booleanConstant false)
  local 'tmp_buf' (newList _nr_sensors)
  if (minmax == 'minimum') {
    command 'get minimum'
  } (minmax == 'maximum') {
    command 'get maximum'
  }
  '[sensors:i2cRead]' 51 tmp_buf
  _can_measure = (booleanConstant true)
  return tmp_buf
}

to 'get position' {
  local 'adc' 0
  local 'sum' 0
  local 'weightsum' 0
  local 'val' 0
  adc = ('read line')
  for i _nr_sensors {
    val = (at i adc)
    if (val < 50) {
      val = 0
    }
    sum = (sum + val)
    weightsum = (weightsum + ((i + 0) * val))
  }
  if (sum != 0) {
    return ((((weightsum * 255) / sum) - 255) / 7)
  }
  return 0
}

to 'get version' {
  _can_measure = (booleanConstant false)
  local 'tmp' (newList 2)
  command 'get version'
  '[sensors:i2cRead]' 51 tmp
  _can_measure = (booleanConstant false)
  return tmp
}

to init_line 'number of sensors' plot {
  _nr_sensors = (v 'number of sensors')
  _line_plot = plot
  _inverted = (booleanConstant false)
  _can_measure = (booleanConstant true)
  if plot {
    'enable lvgl' true true
    for i _nr_sensors {
      '[tft:LVGLaddobj]' 'bar' ('_bar_nr' i)
      '[tft:LVGLsetsize]' ('_bar_nr' i) 15 100
      '[tft:LVGLsetpos]' ('_bar_nr' i) (((_nr_sensors * 20) - (i * 20)) + 20) 20
      '[tft:LVGLsetcolor]' ('_bar_nr' i) (colorSwatch 190 29 9 255) (colorSwatch 255 0 10 255)
      '[tft:LVGLsetattribute]' 'range' ('_bar_nr' i) 0 255
    }
  }
  _line_buf = (newList (_nr_sensors + 4))
}

to invert inverted {
  _inverted = inverted
}

to 'is calibrated' {
  _can_measure = (booleanConstant false)
  local 'buf' (newList 1)
  command 'is calibrated'
  '[sensors:i2cRead]' 51 buf
  _can_measure = (booleanConstant true)
  return ((at 1 buf) == 1)
}

to 'led mode' mode {
  local 'led_mode' 0
  if (mode == 'off') {
    led_mode = 0
  } (mode == 'on') {
    led_mode = 1
  } (mode == 'inverted') {
    led_mode = 2
  } (mode == 'position') {
    led_mode = 3
  }
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 13 led_mode)
}

to 'load calibration' {
  local 'vals' 0
  '[file:open]' 'cal_val.bin'
  tmp = ('[data:convertType]' ('[file:readBytes]' 8 'cal_val.bin') 'list')
  if ((size tmp) > 0) {
    'set calibration' 'minimum' tmp
    tmp = ('[data:convertType]' ('[file:readBytes]' 8 'cal_val.bin') 'list')
    'set calibration' 'maximum' tmp
    '[file:close]' 'cal_val.bin'
  } else {
    sayIt 'no callibration file found'
  }
}

to neopixel nr color {
  local 'r' ((color >> 16) & 255)
  local 'g' ((color >> 8) & 255)
  local 'b' (color & 255)
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 12 (nr - 1) r g b)
}

to position_i2c {
  return _line_pos
}

to 'read line' {
  if _can_measure {
    '[sensors:i2cRead]' 51 _line_buf
    if _inverted {
      for i _nr_sensors {
        atPut i _line_buf (255 - (at i _line_buf))
      }
    }
    if _line_plot {
      for i _nr_sensors {
        '[tft:LVGLsetval]' ('_bar_nr' i) (at i _line_buf)
      }
    }
    _line_pos = (at (_nr_sensors + 1) _line_buf)
    _line_min = (at (_nr_sensors + 2) _line_buf)
    _line_max = (at (_nr_sensors + 3) _line_buf)
    _line_derivative = (at (_nr_sensors + 4) _line_buf)
    return _line_buf
  }
}

to 'restore calibration' {
  _can_measure = (booleanConstant false)
  command 'load calibration'
  waitMillis 500
  _can_measure = (booleanConstant true)
}

to 'save calibration' {
  local 'vals' 0
  if ('is calibrated') {
    vals = ('get calibration' 'minimum')
    if ((size vals) > 0) {
      '[file:close]' 'cal_val.bin'
      '[file:delete]' 'cal_val.bin'
      '[file:open]' 'cal_val.bin'
      '[file:appendBytes]' ('[data:convertType]' vals 'byte array') 'cal_val.bin'
      vals = ('get calibration' 'maximum')
      '[file:appendBytes]' ('[data:convertType]' vals 'byte array') 'cal_val.bin'
      '[file:close]' 'cal_val.bin'
    } else {
      sayIt 'not yet calibrated'
    }
  } else {
    sayIt 'not yet calibrated'
  }
}

to 'set calibration' minmax values {
  if ((size values) != _nr_sensors) {
    sayIt 'length of value array is not equal to number of sensors'
  } else {
    if (minmax == 'minimum') {
      '[sensors:i2cWrite]' 51 ('[data:join]' ('[data:makeList]' 10) values)
    } else {
      '[sensors:i2cWrite]' 51 ('[data:join]' ('[data:makeList]' 11) values)
    }
  }
}

to 'set emitter level' level {
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 14 level)
}

to 'store calibration' {
  _can_measure = (booleanConstant false)
  command 'save calibration'
  comment 'wait some safe time'
  waitMillis 1000
  _can_measure = (booleanConstant true)
}

