module main
author unknown
version 1 0 
description ''

  spec 'r' 'linepos' 'linepos'
  spec ' ' 'lineoff' 'lineoff'
  spec ' ' 'lineon' 'lineon'

to lineoff {
  neoPixelSetAllToColor (colorSwatch 25 4 75 255)
  'set emitter level' false
  'led mode' 'off'
}

to lineon {
  sayIt 123
  neoPixelSetAllToColor (colorSwatch 75 12 0 255)
  'line init'
  'set emitter level' true
  'led mode' 'on'
  'restore calibration'
  command 'mode calibrated'
}

to linepos {
  return ('[data:makeList]' (position) ('line sensor shape'))
}

script 199 62 {
whenStarted
neoPixelAttach 1 25
neoPixelSetAllToColor (colorSwatch 13 75 11 255)
init
forever {
  process
  'line sensor update'
}
}

script 552 283 (position)

script 757 298 ('line sensor shape')

script 179 321 {
to lineon {}
}

script 572 397 {
to linepos {}
}

script 193 570 {
to lineoff {}
}

script 744 3102 ('[serial:read]')


module 'Line Follower' Input
author Ste7an
version 1 4 
choices led_modes off on inverted position 
choices commands 'mode raw' 'mode calibrated' 'get version' debug calibrate 'is calibrated' 'load calibration' 'save calibration' 'get minimum' 'get maximum' 'set minimum' 'set maximum' neopixel 'set leds' 
description 'I2C Line follower on ch32v203'
variables _can_measure _line_data _line_inverted 

  spec ' ' 'line init' 'line sensor init'
  spec ' ' 'line sensor update' 'line sensor update'
  spec ' ' 'line sensor invert' 'line sensor invert _' 'bool' true
  spec 'r' 'read line' 'line sensor values'
  spec 'r' 'position' 'line position'
  spec 'r' 'line position derative' 'line position deravitive'
  spec 'r' 'line sensor shape' 'line sensor shape'
  space
  spec ' ' 'command' 'line sensor command _ : value _' 'str.commands num' 'mode raw' 0
  spec 'r' 'get version' 'line sensor  version'
  space
  spec 'r' 'is calibrated' 'line sensor is calibrated'
  spec ' ' 'store calibration' 'store calibration'
  spec ' ' 'restore calibration' 'restore calibration'
  space
  spec ' ' 'set emitter level' 'enable emitters _' 'bool' true
  spec ' ' 'led mode' 'led mode _' 'str.led_modes' 'on'
  spec ' ' 'neopixel' 'set NeoPixel _ color _' 'auto color' 10

to command cmd args {
  local 'cmd_id' 0
  if (cmd == 'mode raw') {
    cmd_id = 0
  } (cmd == 'mode calibrated') {
    cmd_id = 1
  } (cmd == 'get version') {
    cmd_id = 2
  } (cmd == 'debug') {
    cmd_id = 3
  } (cmd == 'calibrate') {
    cmd_id = 4
  } (cmd == 'is calibrated') {
    cmd_id = 5
  } (cmd == 'load calibration') {
    cmd_id = 6
  } (cmd == 'save calibration') {
    cmd_id = 7
  } (cmd == 'get minimum') {
    cmd_id = 8
  } (cmd == 'get maximum') {
    cmd_id = 9
  } (cmd == 'set minimum') {
    cmd_id = 10
  } (cmd == 'set maximum') {
    cmd_id = 11
  } (cmd == 'neopixel') {
    cmd_id = 12
  } (cmd == 'set leds') {
    cmd_id = 13
  } (cmd == 'set emitter') {
    cmd_id = 14
  }
  if ((argOrDefault 2 'None') == 'None') {
    local 'buf' ('[data:makeList]' cmd_id)
  } else {
    local 'buf' ('[data:makeList]' cmd_id args)
  }
  '[sensors:i2cWrite]' 51 buf
}

to 'get version' {
  _can_measure = (booleanConstant false)
  local 'tmp' (newList 2)
  command 'get version'
  '[sensors:i2cRead]' 51 tmp
  _can_measure = (booleanConstant false)
  return ('[data:join]' (at 1 tmp) '.' (at 2 tmp))
}

to 'is calibrated' {
  _can_measure = (booleanConstant false)
  local 'buf' (newList 1)
  command 'is calibrated'
  '[sensors:i2cRead]' 51 buf
  _can_measure = (booleanConstant true)
  return ((at 1 buf) == 1)
}

to 'led mode' mode {
  local 'led_mode' 0
  if (mode == 'off') {
    led_mode = 0
  } (mode == 'on') {
    led_mode = 1
  } (mode == 'inverted') {
    led_mode = 2
  } (mode == 'position') {
    led_mode = 3
  }
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 13 led_mode)
}

to 'line init' {
  _can_measure = (booleanConstant true)
}

to 'line position derative' {
  return ((at 12 _line_data) - 128)
}

to 'line sensor invert' inverted {
  _line_inverted = inverted
}

to 'line sensor shape' {
  return (at 13 _line_data)
}

to 'line sensor update' {
  _line_data = (newList 13)
  if _can_measure {
    '[sensors:i2cRead]' 51 _line_data
  }
}

to neopixel nr color {
  local 'r' ((color >> 16) & 255)
  local 'g' ((color >> 8) & 255)
  local 'b' (color & 255)
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 12 (nr - 1) r g b)
}

to position {
  return ((at 9 _line_data) - 128)
}

to 'read line' {
  local 'buf' (newList 8)
  if _line_inverted {
    for i 8 {
      atPut i buf (255 - (at i _line_data))
    }
  } else {
    for i 8 {
      atPut i buf (at i _line_data)
    }
  }
  return buf
}

to 'restore calibration' {
  _can_measure = (booleanConstant false)
  command 'load calibration'
  waitMillis 500
  _can_measure = (booleanConstant true)
}

to 'set emitter level' enable {
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 14 ('[data:convertType]' enable 'number')) true
}

to 'store calibration' {
  _can_measure = (booleanConstant false)
  command 'save calibration'
  comment 'wait some safe time'
  waitMillis 1000
  _can_measure = (booleanConstant true)
}


module NeoPixel Output
author MicroBlocks
version 1 15 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels _np_pin _np_haswhite 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'setNeoPixelColors25' 'set NeoPixels #BR# _ _ _ _ _ #BR# _ _ _ _ _ #BR# _ _ _ _ _ #BR# _ _ _ _ _ #BR# _ _ _ _ _' 'color color color color color color color color color color color color color color color color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'neoPixel_colorSwatch' '_' 'color'
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  space
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  spec ' ' 'NeoPixel_shift_color' 'shift NeoPixel _ color by _' 'num num' 1 10
  spec ' ' 'NeoPixel_shift_all_colors' 'shift all NeoPixel colors by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'
  spec ' ' '_NeoPixel_shift_hue' '_NeoPixel_shift_hue of _ by _' 'auto auto' '10' '10'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to NeoPixel_shift_all_colors delta {
  for i (size _np_pixels) {
    '_NeoPixel_shift_hue' i delta
  }
  '_NeoPixel_update'
}

to NeoPixel_shift_color i delta {
  '_NeoPixel_shift_hue' i delta
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if (or ((boardType) == 'M5Atom-Matrix') (or ((boardType) == 'Mbits') ((boardType) == 'micro:STEAMakers'))) {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Foxbit') {
    neoPixelAttach 35 '' false
  } ((boardType) == 'CodingBox') {
    neoPixelAttach 35 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'h' ('[misc:hue]' rgb)
    local 's' ('[misc:saturation]' rgb)
    local 'v' (('[misc:brightness]' rgb) + delta)
    v = (maximum 20 (minimum v 100))
    atPut i _np_pixels ('[misc:hsvColor]' h s v)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_shift_hue' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'h' ((('[misc:hue]' rgb) + delta) % 360)
    local 's' ('[misc:saturation]' rgb)
    local 'v' ('[misc:brightness]' rgb)
    atPut i _np_pixels ('[misc:hsvColor]' h s v)
  }
}

to '_NeoPixel_update' {
  comment 'NeoPixel pin and hasWhite may have been changed by another library.'
  '[display:neoPixelSetPin]' _np_pin _np_hasWhite
  '[display:neoPixelSend]' _np_pixels
  waitMicros 300
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  atPut 'all' _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  _np_pin = pinNumber
  _np_hasWhite = false
  if ((pushArgCount) > 2) {
    _np_hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  atPut 'all' _np_pixels 0
  '[display:neoPixelSetPin]' _np_pin _np_hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  atPut 'all' _np_pixels color
  '_NeoPixel_update'
}

to neoPixel_colorSwatch color {
  return color
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  local 'rotateLeft' (n < 0)
  if (or ((boardType) == 'CircuitPlayground') ((boardType) == 'CircuitPlayground Bluefruit')) {
    rotateLeft = (n > 0)
  }
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' rotateLeft
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  for i (minimum (size _np_pixels) (pushArgCount)) {
    atPut i _np_pixels (getArg i)
  }
  '_NeoPixel_update'
}

to setNeoPixelColors25 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 c16 c17 c18 c19 c20 c21 c22 c23 c24 c25 {
  '_NeoPixel_ensureInitialized'
  for i (minimum (size _np_pixels) (pushArgCount)) {
    atPut i _np_pixels (getArg i)
  }
  '_NeoPixel_update'
}


module microremote
author Ste7an
version 1 0 
description 'Communication library with MicroBlocks using the hubs

UARTDevice.'
variables time 

  spec 'r' '_encode' 'encode _ data _' 'auto auto' 10 '10'
  spec 'r' '_read serial' 'read serial'
  spec 'r' '_decode' 'decode _' 'auto' '10'
  spec 'r' 'call' 'call _ data _' 'auto auto' '10' '10'
  spec 'r' '_receive command' 'receive command'
  spec ' ' '_send command' 'send command _ data _' 'auto auto' '10' '10'
  spec ' ' 'process' 'process'
  spec ' ' 'flush' 'flush'
  spec ' ' 'init' 'init'

to '_decode' encoded {
  local 'tot_len' (size encoded)
  local 'var_list' ('[data:makeList]')
  local 'p' 1
  local 'l' (at p encoded)
  local 'cmd' ('[data:newByteArray]' l)
  for i l {
    atPut i cmd (at ((i + p) - 0) encoded)
  }
  cmd = ('[data:convertType]' cmd 'string')
  p += (l + 1)
  repeatUntil (p > tot_len) {
    local 'type' (at p encoded)
    p += 1
    l = (at p encoded)
    local 'bytes' ('[data:newByteArray]' l)
    for i l {
      atPut i bytes (at ((i + p) - 0) encoded)
    }
    comment '78 = N -> number'
    if (type == 78) {
      bytes = ('[data:convertType]' ('[data:convertType]' bytes 'string') 'number')
    } (type == 83) {
      comment '83 = S -> string'
      bytes = ('[data:convertType]' bytes 'string')
    } (type == 65) {
      comment '65 = A -> bytesarray'
    } (type == 66) {
      comment '66 = B -> boolean'
      bytes = ('[data:convertType]' (at 1 bytes) 'boolean')
    } else {
    }
    p += (l + 1)
    var_list = ('[data:join]' var_list ('[data:makeList]' bytes))
  }
  return ('[data:makeList]' cmd var_list)
}

to '_encode' cmd list {
  local 'list_len' (size list)
  local 'bytes' ('[data:newByteArray]' 0)
  local 'all_bytes' ('[data:newByteArray]' 0)
  for i list_len {
    local 'var' (at i list)
    if (isType var 'number') {
      comment '78 = N -> number'
      local 'str' ('[data:convertType]' var 'string')
      bytes = ('[data:join]' ('[data:asByteArray]' ('[data:makeList]' 78 (size str))) ('[data:convertType]' str 'byte array'))
    } (isType var 'boolean') {
      if var {
        local 'bool' 1
      } else {
        local 'bool' 0
      }
      comment '66 = B -> boolean'
      bytes = ('[data:asByteArray]' ('[data:makeList]' 66 1 bool))
    } (isType var 'string') {
      comment '83 = S -> string'
      bytes = ('[data:join]' ('[data:asByteArray]' ('[data:makeList]' 83 (size var))) ('[data:convertType]' var 'byte array'))
    } (isType var 'list') {
      bytes = 0
    } (isType var 'byte array') {
      comment '65 = A -> bytesarray'
      bytes = ('[data:join]' ('[data:asByteArray]' ('[data:makeList]' 65 (size var))) var)
    }
    all_bytes = ('[data:join]' all_bytes bytes)
  }
  all_bytes = ('[data:join]' ('[data:asByteArray]' (size cmd)) ('[data:asByteArray]' cmd) all_bytes)
  return all_bytes
}

to '_read serial' {
  local 'byte' 0
  local 'PREAMBLE' ('[data:asByteArray]' '<$MU')
  local 'start_time' (millisOp)
  local 'tot_len' 0
  waitUntil (or (((millisOp) - start_time) > 1000) (('[serial:available]') > 0))
  if (('[serial:available]') > 0) {
    tot_len = (at 1 ('[serial:readNr]' 1))
  } else {
    local 'tmp' ('[serial:read]')
    return ('[data:newByteArray]' 0)
  }
  local 'buf' ('[data:newByteArray]' (tot_len - 4))
  local 'idx' 1
  local 'frameStart' (millisOp)
  local 'byteStart' (millisOp)
  repeatUntil (idx > tot_len) {
    if (((millisOp) - frameStart) > 1000) {
      local 'tmp' ('[serial:read]')
      return ('[data:newByteArray]' 0)
    }
    if (('[serial:available]') > 0) {
      byte = (at 1 ('[serial:readNr]' 1))
      if (idx < 5) {
        comment 'check preamble'
        if (byte != (at idx PREAMBLE)) {
          sayIt idx (at idx buf) (at idx PREAMBLE)
          local 'tmp' ('[serial:read]')
          return ('[data:newByteArray]' 0)
        }
      } else {
        atPut (idx - 4) buf byte
      }
      idx += 1
      byteStart = (millisOp)
    } else {
      if (((millisOp) - byteStart) > 10) {
        local 'tmp' ('[serial:read]')
        return ('[data:newByteArray]' 0)
      }
    }
  }
  return buf
}

to '_receive command' {
  local 'bytes' ('_read serial')
  if ((size bytes) > 0) {
    return ('_decode' bytes)
  }
  return ('[data:makeList]')
}

to '_send' cmd data {
  local 'bytes' ('_encode' cmd data)
  bytes = ('[data:join]' ('[data:asByteArray]' (size bytes)) bytes)
  '[serial:write]' bytes
}

to '_send command' cmd data {
  local 'PREAMBLE' '<$MU'
  local 'bytes' ('[data:join]' ('[data:asByteArray]' PREAMBLE) ('_encode' cmd data))
  bytes = ('[data:join]' ('[data:asByteArray]' (size bytes)) bytes)
  '[serial:write]' bytes
}

to call cmd data {
  '_send command' cmd data
  return ('_receive command')
}

to flush {
  local 'var' 0
  repeatUntil (('[serial:available]') > 0) {
    var = ('[serial:read]')
  }
}

to init {
  comment 'init serial port at 115200 and empty buffer'
  '[serial:open]' 115200
  local 'var' ('[serial:read]')
}

to process {
  local 'cmd_data' ('_receive command')
  if (not ((size cmd_data) == 0)) {
    local 'cmd' (at 1 cmd_data)
    local 'data' (at 2 cmd_data)
    local 'return' (callCustomReporter cmd data)
    if (isType return 'boolean') {
      return = ('[data:makeList]')
    } (not (isType return 'list')) {
      return = ('[data:makeList]' return)
    }
    cmd = ('[data:join]' cmd '_ack')
    '_send command' cmd return
  }
}

