module main
author unknown
version 1 0 
description ''
variables count calibrate time_ms _line_pos _line_min _line_max _line_derivative 

  spec ' ' 'calibrate' 'calibrate _' 'auto' 200
  spec ' ' 'Calibrate' 'Calibrate'
  spec ' ' 'inverting' 'inverting'
  spec ' ' 'switch' 'switch'
  spec ' ' 'Load' 'Load'

to Calibrate {
  '[tft:LVGLsetcolor]' 'Calibrate' (colorSwatch 244 14 72 255)
  calibrate = (booleanConstant true)
}

to Load {
  sayIt 123
  command 'load calibration'
}

to calibrate nr {
  command 'calibrate'
  for i nr {
    local 'var' ('read line')
  }
  command 'val_raw'
}

to inverting {
  invert ('[tft:LVGLgetval]' 'inverting')
}

to switch {
  if ('[tft:LVGLgetval]' 'switch') {
    command 'mode calibrated'
  } else {
    command 'mode raw'
  }
}

script 194 50 ('is calibrated')

script 57 59 ('read line')

script 784 76 {
'save calibration'
}

script 982 85 {
'set emitter level' 0
}

script 459 90 {
'[file:open]' 'cal_val.bin'
}

script 195 98 ('get calibration' 'minimum')

script 785 127 {
'load calibration'
}

script 191 139 ('get calibration' 'maximum')

script 461 143 ('[file:readBytes]' 8 'cal_val.bin')

script 183 185 {
command 'save calibration'
}

script 496 202 {
'[file:close]' 'cal_val.bin'
}

script 735 205 (v _line_buf)

script 1026 211 (v _line_min)

script 900 212 (v _line_pos)

script 1136 213 (v _line_max)

script 279 233 {
'led mode' 'position'
}

script 60 234 ('get version')

script 70 274 ('is calibrated')

script 281 290 {
whenCondition calibrate
comment 'start calibration for 10 seconds'
command 'calibrate'
waitMillis 10000
if ('[tft:LVGLgetval]' 'cal_val') {
  command 'mode calibrated'
} else {
  command 'mode raw'
}
'[tft:LVGLsetcolor]' 'Calibrate' (colorSwatch 16 63 244 255)
calibrate = (booleanConstant false)
}

script 625 290 {
whenStarted
comment 'start line follower with 8 sensors and plot'
init_line 8 true
command 'mode raw'
init_callback
comment 'make simple GUI for calibration etc.'
'[tft:LVGLaddbtn]' 'Calibrate'
'[tft:LVGLsetcolor]' 'Calibrate' (colorSwatch 16 63 244 255)
'[tft:LVGLsetpos]' 'Calibrate' 30 140
'[tft:LVGLaddbtn]' 'Load'
'[tft:LVGLsetpos]' 'Load' 30 180
'[tft:LVGLaddobj]' 'switch' 'switch'
'[tft:LVGLsetpos]' 'switch' 140 140
'[tft:LVGLsetsize]' 'switch' 70 40
'[tft:LVGLaddlabel]' 'cal_val' 1 'cal val'
'[tft:LVGLsetpos]' 'cal_val' 150 120
'[tft:LVGLaddobj]' 'switch' 'inverting'
'[tft:LVGLsetsize]' 'inverting' 70 40
'[tft:LVGLsetpos]' 'inverting' 140 200
'[tft:LVGLaddlabel]' 'lab_invert' 1 'invert'
'[tft:LVGLsetpos]' 'lab_invert' 150 180
add_callback 'Calibrate'
'[tft:LVGLaddobj]' 'bar' 'position'
'[tft:LVGLsetsize]' 'position' 20 200
'[tft:LVGLsetpos]' 'position' 240 20
comment 'position ranges need to be checked'
'[tft:LVGLsetattribute]' 'range' 'position' 0 255
add_callback 'switch'
add_callback 'inverting'
add_callback 'Load'
add_command 'line' 9 0 'h'
calibrate = (booleanConstant false)
forever {
  a = ('read line')
  handle_event
  comment 'add green process here when connected to lego'
  buf = (newList 12)
  graphIt (_line_pos - 128) (_line_derivative - 128)
  '[tft:LVGLsetval]' 'position' _line_pos
}
}

script 73 335 {
'store calibration'
}

script 52 457 {
'restore calibration'
}

script 123 696 {
to switch {}
}

script 123 696 {
to switch {}
}

script 123 696 {
to switch {}
}

script 123 696 {
to switch {}
}

script 380 714 {
to Calibrate {}
}

script 390 894 {
to Load {}
}

script 390 894 {
to Load {}
}

script 390 894 {
to Load {}
}

script 390 894 {
to Load {}
}

script 123 950 {
to inverting {}
}

script 92 1188 {
'led mode' 'off'
forever {
  for i 8 {
    neopixel (((i - 2) % 8) + 1) (colorSwatch 0 0 0 255)
    neopixel i (colorSwatch 1 2 23 255)
    waitMillis 50
  }
  for i 8 {
    neopixel ((((9 - i) - 0) % 8) + 1) (colorSwatch 0 0 0 255)
    neopixel (9 - i) (colorSwatch 1 2 23 255)
    waitMillis 50
  }
}
}

script 50 1611 {
to 'store calibration' {}
}

script 50 1818 {
to 'read line' {}
}


module Files Data
author MicroBlocks
version 1 4 
description 'Flash file system operations. Currently supports the LittleFS file system on ESP8266 and ESP32 boards. The GnuBlocks virtual machine (Linux and Raspberry Pi) supports the native system.'

  spec ' ' '[file:open]' 'open file _' 'str'
  spec ' ' '[file:close]' 'close file _' 'str'
  spec ' ' '[file:delete]' 'delete file _' 'str'
  space
  spec ' ' '[file:appendLine]' 'append line _ to file _' 'str str'
  spec ' ' '[file:appendBytes]' 'append bytes _ to file _' 'str str'
  space
  spec 'r' '[file:fileSize]' 'size of file _' 'str'
  spec 'r' 'file_contents' 'contents of file _ : binary _' 'str bool' '' false
  space
  spec 'r' '[file:readLine]' 'next line of file _' 'str'
  spec 'r' '[file:readBytes]' 'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0
  spec 'r' '[file:readInto]' 'read into _ from file _' 'str str' 'a ByteArray' ''
  spec 'r' '[file:endOfFile]' 'end of file _' 'str'
  space
  spec 'r' '[file:readPosition]' 'read position of file _' 'str'
  spec ' ' '[file:setReadPosition]' 'set read position _ of file _' 'num str' 0 ''
  spec ' ' 'file_SkipBytes' 'skip _ bytes of file _' 'num str' 4 ''
  space
  spec 'r' 'file names' 'file names : in directory _' 'str'
  spec 'r' '[file:systemInfo]' 'file system info'

to 'file names' dir {
  '[file:startList]' dir
  local 'result' ('[data:makeList]')
  local 'fileName' ('[file:nextInList]')
  repeatUntil (fileName == '') {
    '[data:addLast]' fileName result
    fileName = ('[file:nextInList]')
  }
  return result
}

to file_SkipBytes offset file {
  local 'newPosition' (('[file:readPosition]' file) + offset)
  '[file:setReadPosition]' newPosition file
}

to file_contents fileName optionBinary {
  local 'binary' (argOrDefault 2 (booleanConstant false))
  local 'byteCount' ('[file:fileSize]' fileName)
  local 'result' ('[data:newByteArray]' byteCount)
  local 'i' 1
  '[file:open]' fileName
  repeatUntil (i > byteCount) {
    i += ('[file:readInto]' result fileName)
  }
  '[file:close]' fileName
  return (ifExpression binary result ('[data:convertType]' result 'string'))
}


module LVGL Output
author Ste7an
version 1 10 
choices attribute_types range rotation angles brightness 'line width' animation digits increment decrement points length 'tick count' 'major tick every' 'show labels' 'scale mode' 'button ctrl' width focused flags 
choices style_types 'text font' 'text color' 'bg color' 'bg opa' 'border width' 'border color' radius 'shadow width' 'shadow offset x' 'shadow offset y' 'shadow opa' width 'line width' 'line color' 
choices obj_types arc bar led list roller scale screen slider spinbox spinner style switch tabview tileview keyboard textarea 
choices symbols bullet audio video list ok close power settings home download drive refresh mute volume_mid volume_max image tint prev play pause stop next eject left right plus minus eye_open eye_close warning shuffle up down loop directory upload call cut copy save bars envelope charge paste bell keyboard gps file wifi battery_full battery_3 battery_2 battery_1 battery_empty usb bluetooth trash edit backspace sd_card new_line 
choices chart_update_mode shift circular 
choices scale_modes 'hor top' 'hor bottom' 'ver left' 'ver right' 'round inner' 'round outer' last 
choices chart_type line bar scatter 
choices scroll_dirs none hor ver all 
description 'LVGL support for MicroBlocks'
variables _lvgl_call_backs 

  spec ' ' 'enable lvgl' 'enable lvgl _ delete all _' 'bool bool' true true
  spec ' ' '[tft:LVGLaddbtn]' 'button _ : scale _ : text _ : parent _' 'str num str str' 'button' 1 'button' 'lv_scr_act'
  spec ' ' '[tft:LVGLaddlabel]' 'label _ : scale _ : text _ : parent _' 'str num str str' 'label' 1 'label' 'lv_scr_act'
  spec ' ' '[tft:LVGLaddobj]' 'add _ as _ : parent _' 'str.obj_types str str' 'arc' '' 'lv_scr_act'
  spec ' ' '[tft:LVGLsetpos]' 'set position _ x _ y _' 'str num num' '' 100 100
  spec ' ' '[tft:LVGLsetsize]' 'set size _ width _ height _' 'str num num' '' 100 10
  spec ' ' '[tft:LVGLsetval]' 'set value _ value _' 'str num' '' 10
  spec 'r' '[tft:LVGLgetval]' 'get value _' 'str' ''
  spec ' ' '[tft:LVGLsettext]' 'set text _ text _ : scale _' 'str str auto' '' 'text' 1
  spec ' ' '[tft:LVGLsetcolor]' 'set color _ background _ : second _ : third _' 'str color color color' ''
  spec 'r' 'lvgl_color' '_' 'color'
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  space
  spec 'r' '[tft:LVGLevent]' 'event available'
  spec 'r' '[tft:LVGLgetevent]' 'get event'
  space
  spec 'r' 'screen' 'screen'
  spec 'r' 'symbol' 'symbol _' 'str.symbols' 'bullet'
  spec ' ' '[tft:LVGLsetparent]' 'set _ parent _ : states _ : parts _' 'str str num num' '' '' 0 0
  spec 'r' '[tft:LVGLgetallobjs]' 'get all objects'
  spec ' ' '[tft:LVGLdelobj]' 'delete object _' 'str' ''
  spec ' ' 'delete_all_objects' 'delete all objects'
  spec ' ' '[tft:LVGLaddimg]' 'image path _  as  _ : parent _' 'str str str' '' 'img' 'lv_scr_act'
  spec ' ' '[tft:LVGLaddfont]' 'font path _  as  _' 'str str' '' ''
  spec ' ' '[tft:LVGLsetattribute]' 'set attribute _ of _ first _ : second _' 'str.attribute_types str auto auto' 'range' '' '' ''
  spec ' ' '[tft:LVGLsetstyle]' 'set style _ of _ to _' 'str.style_types str auto' 'text font' '' ''
  spec 'r' 'set_states' 'state pressed _ : checked _ : scrolled _' 'bool bool bool bool' true false false
  spec 'r' 'set_parts' 'parts selected _ : indicator _ : knob _ : #BR# items _ : scrollbar _' 'bool bool bool bool bool' true false false false false
  spec 'r' 'set_scale_mode' 'scale mode _' 'str.scale_modes' 'hor top'
  spec 'r' 'set_button_ctrl' 'button ctrl checkable _ : checked _ : hidden _ : disabled _' 'bool bool bool bool' true false false false
  spec 'r' 'set_flag' 'behaviour flags hidden _ : clickable _ : checkable _ : scrollable : _ : scroll one _' 'bool bool bool bool bool' false false false false false
  spec ' ' '[tft:LVGLsetscroll]' 'set scroll direction of _ to _' 'str str.scroll_dirs' '' 'none'
  spec ' ' '[tft:LVGLloadscreen]' 'load screen _' 'str' ''
  spec ' ' '[tft:LVGLaddtab]' 'tab _ parent _' 'str str' 'tab' ''
  spec ' ' '[tft:LVGLaddbuttonmatrix]' 'button matrix _ elements _ : parent _' 'str auto str' '' 'aList' 'lv_scr_act'
  spec ' ' '[tft:LVGLaddchart]' 'chart _ type _ update mode _ : parent _' 'str str.chart_type str.chart_update_mode str' '' 'line' 'shift' 'lv_scr_act'
  spec ' ' '[tft:LVGLaddseries]' 'add series _ chart _ color _' 'str str color' '' ''
  spec ' ' '[tft:LVGLsetnextvalue]' 'add value to series _ from chart _ value _ : value2 _' 'str str num num' '' '' 0 0
  spec ' ' '[tft:LVGLaddtile]' 'tile _ parent _ col _ row _ #BR# L _ R _ T _ B _' 'str str num num bool bool bool bool' 'tile' '' 0 0 false false false false
  spec 'r' '[tft:LVGLpsram]' 'get PSRAM'
  spec ' ' 'init_callback' 'init callback'
  spec ' ' 'add_callback' 'add callback _ : function _' 'str str' '' ''
  spec ' ' 'handle_event' 'handle event'

to add_callback obj function {
  if (not (isType _lvgl_call_backs 'list')) {_lvgl_call_backs = ('[data:makeList]')}
  if ((pushArgCount) < 2) {
    '[data:addLast]' ('[data:makeList]' obj obj) _lvgl_call_backs
  } else {
    '[data:addLast]' ('[data:makeList]' obj function) _lvgl_call_backs
  }
}

to delete_all_objects {
  local 'all_objects' ('[tft:LVGLgetallobjs]')
  for i (size all_objects) {
    if ((at i all_objects) != '!main_screen_default') {'[tft:LVGLdelobj]' (at i all_objects)}
  }
  comment 'load original main screen that is stored'
  '[tft:LVGLloadscreen]' '!main_screen_default'
}

to 'enable lvgl' enable delete {
  callCustomCommand '[tft:LVGLon]' ('[data:makeList]' enable)
  if delete {
    delete_all_objects
  }
}

to handle_event {
  if ('[tft:LVGLevent]') {
    local 'var' 1
    local 'event' ('[tft:LVGLgetevent]')
    repeatUntil (or (var > (size _lvgl_call_backs)) (event == (at 1 (at var _lvgl_call_backs)))) {
      var += 1
    }
    if (var <= (size _lvgl_call_backs)) {
      callCustomCommand (at 2 (at var _lvgl_call_backs))
    }
  }
}

to init_callback {
  _lvgl_call_backs = 0
}

to lvgl_color color {
  return color
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to screen {
  return 'lv_scr_act'
}

to set_button_ctrl checkable checked hidden disabled {
  return (sum (ifExpression checkable (hexToInt '80') 0) (ifExpression checked (hexToInt '100') 0) (ifExpression hidden (hexToInt '10') 0) (ifExpression disabled (hexToInt '40') 0))
}

to set_flag hidden clickable checkable scrollable scroll_one {
  return (sum (ifExpression hidden (hexToInt '1') 0) (ifExpression clickable (hexToInt '2') 0) (ifExpression checkable (hexToInt '8') 0) (ifExpression scrollable (hexToInt '10') 0) (ifExpression scroll_one (hexToInt '80') 0))
}

to set_parts selected indicator knob items scrollbar {
  return (sum (ifExpression scrollbar (hexToInt '10000') 0) (ifExpression indicator (hexToInt '20000') 0) (ifExpression knob (hexToInt '30000') 0) (ifExpression selected (hexToInt '40000') 0) (ifExpression items (hexToInt '50000') 0))
}

to set_scale_mode mode {
  if (mode == 'hor top') {
    return 0
  } (mode == 'hor bottom') {
    return 1
  } (mode == 'ver left') {
    return 2
  } (mode == 'ver right') {
    return 4
  } (mode == 'round inner') {
    return 8
  } (mode == 'round outer') {
    return 16
  } else {
    return 0
  }
}

to set_states pressed checked scrolled {
  return (sum (ifExpression checked 1 0) (ifExpression pressed (hexToInt '20') 0) (ifExpression scrolled (hexToInt '40') 0))
}

to symbol symbolname {
  return ('[data:unicodeString]' (callCustomReporter '[tft:LVGLgetsymbol]' ('[data:makeList]' symbolname)))
}


module 'Line Follower' Input
author Ste7an
version 1 3 
choices set_calibration minimum maximum 
choices get_calibration minimum maximum average 
choices led_modes off on inverted position 
choices commands 'mode raw' 'mode calibrated' 'get version' debug calibrate 'is calibrated' 'load calibration' 'save calibration' 'get minimum' 'get maximum' 'set minimum' 'set maximum' neopixel 'set leds' 
description 'I2C Line follower on ch32v203'
variables _buf _line_plot _line_buf a _inverted _nr_sensors tmp buf _can_measure 

  spec ' ' 'init_line' 'init line _ plot _' 'num bool' 8 true
  spec 'r' 'read line' 'read line'
  spec 'r' '_bar_nr' '_bar_nr _' 'auto' '10'
  spec ' ' 'invert' 'invert _' 'bool' true
  spec 'r' 'get position' 'get position'
  spec ' ' 'set emitter level' 'set emitter level _' 'auto' '10'
  spec ' ' 'set calibration' 'set calibration _ values _' 'str.set_calibration auto' 'minimum' '10'
  spec ' ' 'command' 'command _ : value _' 'str.commands num' 'mode raw' 0
  spec 'r' 'get calibration' 'get calibration _' 'str.get_calibration' 'minimum'
  spec 'r' 'is calibrated' 'is calibrated'
  spec ' ' 'save calibration' 'calibration to file'
  spec ' ' 'load calibration' 'calibration from file'
  spec 'r' 'position_i2c' 'position_i2c'
  spec ' ' 'store calibration' 'store calibration'
  spec ' ' 'restore calibration' 'restore calibration'
  spec ' ' 'neopixel' 'neopixel _ color _' 'auto color' '10'
  spec ' ' 'led mode' 'led mode _' 'str.led_modes' 'on'
  spec 'r' 'get version' 'get version'

to '_bar_nr' nr {
  return ('[data:join]' 'bar' nr)
}

to command cmd args {
  local 'cmd_id' 0
  if (cmd == 'mode raw') {
    cmd_id = 0
  } (cmd == 'mode calibrated') {
    cmd_id = 1
  } (cmd == 'get version') {
    cmd_id = 2
  } (cmd == 'debug') {
    cmd_id = 3
  } (cmd == 'calibrate') {
    cmd_id = 4
  } (cmd == 'is calibrated') {
    cmd_id = 5
  } (cmd == 'load calibration') {
    cmd_id = 6
  } (cmd == 'save calibration') {
    cmd_id = 7
  } (cmd == 'get minimum') {
    cmd_id = 8
  } (cmd == 'get maximum') {
    cmd_id = 9
  } (cmd == 'set minimum') {
    cmd_id = 10
  } (cmd == 'set maximum') {
    cmd_id = 11
  } (cmd == 'neopixel') {
    cmd_id = 12
  } (cmd == 'set leds') {
    cmd_id = 13
  } (cmd == 'set emitter') {
    cmd_id = 14
  }
  if ((argOrDefault 2 'None') == 'None') {
    local 'buf' ('[data:makeList]' cmd_id)
  } else {
    local 'buf' ('[data:makeList]' cmd_id args)
  }
  '[sensors:i2cWrite]' 51 buf
}

to 'get calibration' minmax {
  _can_measure = (booleanConstant false)
  local 'tmp_buf' (newList _nr_sensors)
  if (minmax == 'minimum') {
    command 'get minimum'
  } (minmax == 'maximum') {
    command 'get maximum'
  }
  '[sensors:i2cRead]' 51 tmp_buf
  _can_measure = (booleanConstant true)
  return tmp_buf
}

to 'get position' {
  local 'adc' 0
  local 'sum' 0
  local 'weightsum' 0
  local 'val' 0
  adc = ('read line')
  for i _nr_sensors {
    val = (at i adc)
    if (val < 50) {
      val = 0
    }
    sum = (sum + val)
    weightsum = (weightsum + ((i + 0) * val))
  }
  if (sum != 0) {
    return ((((weightsum * 255) / sum) - 255) / 7)
  }
  return 0
}

to 'get version' {
  _can_measure = (booleanConstant false)
  local 'tmp' (newList 2)
  command 'get version'
  '[sensors:i2cRead]' 51 tmp
  _can_measure = (booleanConstant false)
  return tmp
}

to init_line 'number of sensors' plot {
  _nr_sensors = (v 'number of sensors')
  _line_plot = plot
  _inverted = (booleanConstant false)
  _can_measure = (booleanConstant true)
  if plot {
    'enable lvgl' true true
    for i _nr_sensors {
      '[tft:LVGLaddobj]' 'bar' ('_bar_nr' i)
      '[tft:LVGLsetsize]' ('_bar_nr' i) 15 100
      '[tft:LVGLsetpos]' ('_bar_nr' i) (((_nr_sensors * 20) - (i * 20)) + 20) 20
      '[tft:LVGLsetcolor]' ('_bar_nr' i) (colorSwatch 190 29 9 255) (colorSwatch 255 0 10 255)
      '[tft:LVGLsetattribute]' 'range' ('_bar_nr' i) 0 255
    }
  }
  _line_buf = (newList (_nr_sensors + 4))
}

to invert inverted {
  _inverted = inverted
}

to 'is calibrated' {
  _can_measure = (booleanConstant false)
  local 'buf' (newList 1)
  command 'is calibrated'
  '[sensors:i2cRead]' 51 buf
  _can_measure = (booleanConstant true)
  return ((at 1 buf) == 1)
}

to 'led mode' mode {
  local 'led_mode' 0
  if (mode == 'off') {
    led_mode = 0
  } (mode == 'on') {
    led_mode = 1
  } (mode == 'inverted') {
    led_mode = 2
  } (mode == 'position') {
    led_mode = 3
  }
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 13 led_mode)
}

to 'load calibration' {
  local 'vals' 0
  '[file:open]' 'cal_val.bin'
  tmp = ('[data:convertType]' ('[file:readBytes]' 8 'cal_val.bin') 'list')
  if ((size tmp) > 0) {
    'set calibration' 'minimum' tmp
    tmp = ('[data:convertType]' ('[file:readBytes]' 8 'cal_val.bin') 'list')
    'set calibration' 'maximum' tmp
    '[file:close]' 'cal_val.bin'
  } else {
    sayIt 'no callibration file found'
  }
}

to neopixel nr color {
  local 'r' ((color >> 16) & 255)
  local 'g' ((color >> 8) & 255)
  local 'b' (color & 255)
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 12 (nr - 1) r g b)
}

to position_i2c {
  return _line_pos
}

to 'read line' {
  if _can_measure {
    '[sensors:i2cRead]' 51 _line_buf
    if _inverted {
      for i _nr_sensors {
        atPut i _line_buf (255 - (at i _line_buf))
      }
    }
    if _line_plot {
      for i _nr_sensors {
        '[tft:LVGLsetval]' ('_bar_nr' i) (at i _line_buf)
      }
    }
    _line_pos = (at (_nr_sensors + 1) _line_buf)
    _line_min = (at (_nr_sensors + 2) _line_buf)
    _line_max = (at (_nr_sensors + 3) _line_buf)
    _line_derivative = (at (_nr_sensors + 4) _line_buf)
    return _line_buf
  }
}

to 'restore calibration' {
  _can_measure = (booleanConstant false)
  command 'load calibration'
  waitMillis 500
  _can_measure = (booleanConstant true)
}

to 'save calibration' {
  local 'vals' 0
  if ('is calibrated') {
    vals = ('get calibration' 'minimum')
    if ((size vals) > 0) {
      '[file:close]' 'cal_val.bin'
      '[file:delete]' 'cal_val.bin'
      '[file:open]' 'cal_val.bin'
      '[file:appendBytes]' ('[data:convertType]' vals 'byte array') 'cal_val.bin'
      vals = ('get calibration' 'maximum')
      '[file:appendBytes]' ('[data:convertType]' vals 'byte array') 'cal_val.bin'
      '[file:close]' 'cal_val.bin'
    } else {
      sayIt 'not yet calibrated'
    }
  } else {
    sayIt 'not yet calibrated'
  }
}

to 'set calibration' minmax values {
  if ((size values) != _nr_sensors) {
    sayIt 'length of value array is not equal to number of sensors'
  } else {
    if (minmax == 'minimum') {
      '[sensors:i2cWrite]' 51 ('[data:join]' ('[data:makeList]' 10) values)
    } else {
      '[sensors:i2cWrite]' 51 ('[data:join]' ('[data:makeList]' 11) values)
    }
  }
}

to 'set emitter level' level {
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 14 level)
}

to 'store calibration' {
  _can_measure = (booleanConstant false)
  command 'save calibration'
  comment 'wait some safe time'
  waitMillis 1000
  _can_measure = (booleanConstant true)
}


module NeoPixel Output
author MicroBlocks
version 1 14 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels _np_pin _np_haswhite 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'setNeoPixelColors25' 'set NeoPixels #BR# _ _ _ _ _ #BR# _ _ _ _ _ #BR# _ _ _ _ _ #BR# _ _ _ _ _ #BR# _ _ _ _ _' 'color color color color color color color color color color color color color color color color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'neoPixel_colorSwatch' '_' 'color'
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  space
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  spec ' ' 'NeoPixel_shift_color' 'shift NeoPixel _ color by _' 'num num' 1 10
  spec ' ' 'NeoPixel_shift_all_colors' 'shift all NeoPixel colors by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'
  spec ' ' '_NeoPixel_shift_hue' '_NeoPixel_shift_hue of _ by _' 'auto auto' '10' '10'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to NeoPixel_shift_all_colors delta {
  for i (size _np_pixels) {
    '_NeoPixel_shift_hue' i delta
  }
  '_NeoPixel_update'
}

to NeoPixel_shift_color i delta {
  '_NeoPixel_shift_hue' i delta
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if (or ((boardType) == 'M5Atom-Matrix') (or ((boardType) == 'Mbits') ((boardType) == 'micro:STEAMakers'))) {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'FOXBIT') {
    neoPixelAttach 35 '' false
  } ((boardType) == 'CodingBox') {
    neoPixelAttach 35 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'h' ('[misc:hue]' rgb)
    local 's' ('[misc:saturation]' rgb)
    local 'v' (('[misc:brightness]' rgb) + delta)
    v = (maximum 20 (minimum v 100))
    atPut i _np_pixels ('[misc:hsvColor]' h s v)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_shift_hue' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'h' ((('[misc:hue]' rgb) + delta) % 360)
    local 's' ('[misc:saturation]' rgb)
    local 'v' ('[misc:brightness]' rgb)
    atPut i _np_pixels ('[misc:hsvColor]' h s v)
  }
}

to '_NeoPixel_update' {
  comment 'NeoPixel pin and hasWhite may have been changed by another library.'
  '[display:neoPixelSetPin]' _np_pin _np_hasWhite
  '[display:neoPixelSend]' _np_pixels
  waitMicros 300
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  atPut 'all' _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  _np_pin = pinNumber
  _np_hasWhite = false
  if ((pushArgCount) > 2) {
    _np_hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  atPut 'all' _np_pixels 0
  '[display:neoPixelSetPin]' _np_pin _np_hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  atPut 'all' _np_pixels color
  '_NeoPixel_update'
}

to neoPixel_colorSwatch color {
  return color
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  local 'rotateLeft' (n < 0)
  if (or ((boardType) == 'CircuitPlayground') ((boardType) == 'CircuitPlayground Bluefruit')) {
    rotateLeft = (n > 0)
  }
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' rotateLeft
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}

to setNeoPixelColors25 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 c16 c17 c18 c19 c20 c21 c22 c23 c24 c25 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  if ((size _np_pixels) >= 11) {
    atPut 11 _np_pixels c11
  }
  if ((size _np_pixels) >= 12) {
    atPut 12 _np_pixels c12
  }
  if ((size _np_pixels) >= 13) {
    atPut 13 _np_pixels c13
  }
  if ((size _np_pixels) >= 14) {
    atPut 14 _np_pixels c14
  }
  if ((size _np_pixels) >= 15) {
    atPut 15 _np_pixels c15
  }
  if ((size _np_pixels) >= 16) {
    atPut 16 _np_pixels c16
  }
  if ((size _np_pixels) >= 17) {
    atPut 17 _np_pixels c17
  }
  if ((size _np_pixels) >= 18) {
    atPut 18 _np_pixels c18
  }
  if ((size _np_pixels) >= 19) {
    atPut 19 _np_pixels c19
  }
  if ((size _np_pixels) >= 20) {
    atPut 20 _np_pixels c20
  }
  if ((size _np_pixels) >= 21) {
    atPut 21 _np_pixels c21
  }
  if ((size _np_pixels) >= 22) {
    atPut 22 _np_pixels c22
  }
  if ((size _np_pixels) >= 23) {
    atPut 23 _np_pixels c23
  }
  if ((size _np_pixels) >= 24) {
    atPut 24 _np_pixels c24
  }
  if ((size _np_pixels) >= 25) {
    atPut 25 _np_pixels c25
  }
  '_NeoPixel_update'
}

